from __future__ import annotations

import argparse
import sys
from pathlib import Path

from .ui import render_rich_help, resolve_output_mode


PROGRAM_TEMPLATE = """# Generated by `loopfarm init`
# Edit this program to match your own loop design.
# To add more programs, create additional TOML files in
# .loopfarm/programs/ (one strict [program] block per file).

[program]
name = "implementation"
project = "{project}"
steps = ["forward*5", "documentation", "architecture", "backward"]
termination_phase = "backward"
report_source_phase = "forward"
report_target_phases = ["documentation", "architecture", "backward"]

[program.phase.forward]
cli = "codex"
prompt = ".loopfarm/prompts/implementation/forward.md"
model = "gpt-5.3-codex"
reasoning = "xhigh"
inject = ["phase_briefing"]

[program.phase.documentation]
cli = "gemini"
prompt = ".loopfarm/prompts/implementation/documentation.md"
model = "gemini-3-pro-preview"

[program.phase.architecture]
cli = "codex"
prompt = ".loopfarm/prompts/implementation/architecture.md"
model = "gpt-5.2"
reasoning = "xhigh"
inject = ["forward_report"]

[program.phase.backward]
cli = "codex"
prompt = ".loopfarm/prompts/implementation/backward.md"
model = "gpt-5.2"
reasoning = "xhigh"
inject = ["forward_report"]
"""

IMPLEMENTATION_PLANNING = """You are running the planning phase.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

## Workflow

1. Explore current issues with `loopfarm issue`.
2. Explore the relevant codebase and current implementation state.
3. Break work into concrete, testable issues.
4. Create/update issue dependencies so execution order is clear.
5. Ensure the loop can proceed without missing context.

Do not implement code in this phase.

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

IMPLEMENTATION_FORWARD = """You are running the forward implementation phase.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

{{PHASE_BRIEFING}}

## Workflow

1. Pick the highest-priority ready issue.
2. Implement changes and tests for that issue.
3. Keep scope tight and avoid unrelated edits.
4. Record progress and blockers in `loopfarm issue` / `loopfarm forum`.

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

IMPLEMENTATION_DOCUMENTATION = """You are running the documentation phase.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

{{FORWARD_REPORT}}

## Workflow

1. Review changed behavior and interfaces from this cycle.
2. Update docs/comments/examples that are now stale.
3. File issues for doc gaps that cannot be resolved immediately.

Do not introduce unrelated implementation changes in this phase.

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

IMPLEMENTATION_ARCHITECTURE = """You are running the architecture/performance review phase.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

{{FORWARD_REPORT}}

## Workflow

1. Review modularity, coupling, performance risks, and scalability.
2. Create follow-up issues under the active implementation epic.
3. Prioritize issues by expected impact and urgency.

Do not implement code in this phase.

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

IMPLEMENTATION_BACKWARD = """You are running the backward review phase (termination gate).

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

{{FORWARD_REPORT}}

## Workflow

1. Audit current loop state and unresolved risks.
2. Verify issue graph is still coherent and actionable.
3. Replan by creating/updating issues when needed.
4. Decide if the loop should continue.

If complete, write status:

```bash
loopfarm forum post "loopfarm:status:{{SESSION}}" -m '{"decision":"COMPLETE","summary":"<brief summary>"}'
```

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

RESEARCH_PLANNING = """You are running research planning.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

## Workflow

1. Define the research scope and unknowns.
2. Create issue structure for research tasks and expected outputs.
3. Define what "implementation-ready" means for this topic.

Do not implement code in this phase.

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

RESEARCH_RESEARCH = """You are running deep research.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

## Workflow

1. Gather evidence from papers, production systems, and source code.
2. Capture findings in durable `loopfarm forum` topics.
3. Tie findings to concrete implementation implications.

Do not implement production code in this phase.

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

RESEARCH_CURATION = """You are running research curation.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

## Workflow

1. Consolidate findings into prioritized implementation guidance.
2. Update issues and dependencies based on evidence.
3. Remove low-value tasks and clarify next execution slices.

Do not implement production code in this phase.

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""

RESEARCH_BACKWARD = """You are running research backward/replanning.

User prompt:

{{PROMPT}}

{{DYNAMIC_CONTEXT}}

## Workflow

1. Audit whether research coverage is sufficient.
2. Identify blocking gaps and create follow-up tasks.
3. Decide if handoff to implementation is ready.

If complete, write status:

```bash
loopfarm forum post "loopfarm:status:{{SESSION}}" -m '{"decision":"COMPLETE","summary":"<brief summary>"}'
```

## Required Phase Summary

---LOOPFARM-PHASE-SUMMARY---

<summary>
---END-LOOPFARM-PHASE-SUMMARY---
"""


def _build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="loopfarm init",
        add_help=False,
        description=(
            "Initialize loopfarm scaffolding in the current directory.\n"
            "Writes .loopfarm/loopfarm.toml and default prompt templates.\n"
            "For multiple programs, add files under .loopfarm/programs/*.toml."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument("-h", "--help", action="store_true", default=False)
    parser.add_argument(
        "--force",
        action="store_true",
        default=False,
        help="Overwrite existing scaffold files",
    )
    parser.add_argument(
        "--project",
        help="Set [program].project in generated config",
    )
    return parser


def _print_help_rich() -> None:
    render_rich_help(
        command="loopfarm init",
        summary="scaffold loopfarm config + default prompts in the current workspace",
        usage=("loopfarm init [--project NAME] [--force]",),
        sections=(
            (
                "Options",
                (
                    (
                        "--project NAME",
                        "set [program].project in generated .loopfarm/loopfarm.toml",
                    ),
                    ("--force", "overwrite existing scaffold files"),
                    ("-h, --help", "show this help"),
                ),
            ),
            (
                "Generated Files",
                (
                    (".loopfarm/loopfarm.toml", "default program config"),
                    (
                        ".loopfarm/prompts/implementation/*.md",
                        "planning/forward/documentation/architecture/backward prompts",
                    ),
                    (
                        ".loopfarm/prompts/research/*.md",
                        "planning/research/curation/backward prompts",
                    ),
                ),
            ),
            (
                "Quick Start",
                (
                    ("bootstrap", "loopfarm init"),
                    ("custom project name", "loopfarm init --project my-repo"),
                    (
                        "rerender templates",
                        "loopfarm init --force",
                    ),
                ),
            ),
        ),
        examples=(
            (
                "loopfarm init --project workshop",
                "initialize with an explicit project identifier",
            ),
            (
                "loopfarm init --force",
                "refresh generated prompts/config after template updates",
            ),
        ),
        docs_tip=(
            "After init, run `loopfarm docs list` to inspect built-in architecture docs."
        ),
    )


def _scaffold_files(project: str) -> dict[Path, str]:
    return {
        Path(".loopfarm/loopfarm.toml"): PROGRAM_TEMPLATE.format(project=project),
        Path(".loopfarm/prompts/implementation/planning.md"): IMPLEMENTATION_PLANNING,
        Path(".loopfarm/prompts/implementation/forward.md"): IMPLEMENTATION_FORWARD,
        Path(
            ".loopfarm/prompts/implementation/documentation.md"
        ): IMPLEMENTATION_DOCUMENTATION,
        Path(".loopfarm/prompts/implementation/architecture.md"): IMPLEMENTATION_ARCHITECTURE,
        Path(".loopfarm/prompts/implementation/backward.md"): IMPLEMENTATION_BACKWARD,
        Path(".loopfarm/prompts/research/planning.md"): RESEARCH_PLANNING,
        Path(".loopfarm/prompts/research/research.md"): RESEARCH_RESEARCH,
        Path(".loopfarm/prompts/research/curation.md"): RESEARCH_CURATION,
        Path(".loopfarm/prompts/research/backward.md"): RESEARCH_BACKWARD,
    }


def _write(path: Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(text.strip() + "\n", encoding="utf-8")


def main(argv: list[str] | None = None) -> None:
    parser = _build_parser()
    args = parser.parse_args(argv or [])

    if args.help:
        try:
            help_output_mode = resolve_output_mode(
                is_tty=getattr(sys.stdout, "isatty", lambda: False)(),
            )
        except ValueError as exc:
            print(f"error: {exc}", file=sys.stderr)
            raise SystemExit(2) from exc
        if help_output_mode == "rich":
            _print_help_rich()
        else:
            parser.print_help()
        raise SystemExit(0)

    repo_root = Path.cwd()
    project = (args.project or repo_root.name).strip() or repo_root.name
    files = _scaffold_files(project)

    created: list[Path] = []
    overwritten: list[Path] = []
    skipped: list[Path] = []

    for rel_path, content in files.items():
        path = repo_root / rel_path
        existed_before = path.exists()
        if existed_before and not args.force:
            skipped.append(rel_path)
            continue
        _write(path, content)
        if existed_before:
            overwritten.append(rel_path)
        else:
            created.append(rel_path)

    for rel_path in created:
        print(f"created: {rel_path}")
    for rel_path in overwritten:
        print(f"overwrote: {rel_path}")
    for rel_path in skipped:
        print(f"skipped: {rel_path}", file=sys.stderr)

    if not created and not overwritten:
        print("nothing changed", file=sys.stderr)


if __name__ == "__main__":
    main(sys.argv[1:])
